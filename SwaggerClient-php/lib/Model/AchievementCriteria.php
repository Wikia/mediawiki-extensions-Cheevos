<?php
/**
 * AchievementCriteria
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swaagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Cheevos API
 *
 * API for Hydra's achievements, quests, and user reporting.
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;

/**
 * AchievementCriteria Class Doc Comment
 *
 * @category    Class */
 // @description Rules for awarding an achievement
/**
 * @package     Swagger\Client
 * @author      Swagger Codegen team
 * @link        https://github.com/swagger-api/swagger-codegen
 */
class AchievementCriteria implements ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      * @var string
      */
    protected static $swaggerModelName = 'AchievementCriteria';

    /**
      * Array of property to type mappings. Used for (de)serialization
      * @var string[]
      */
    protected static $swaggerTypes = [
        'stats' => '\Swagger\Client\Model\Stat[]',
        'value' => 'int',
        'streak' => 'string',
        'streak_progress_required' => 'int',
        'streak_reset_to_zero' => 'bool',
        'per_site_progress_maximum' => 'int',
        'category_id' => 'int',
        'achievement_ids' => 'int[]'
    ];

    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of attributes where the key is the local name, and the value is the original name
     * @var string[]
     */
    protected static $attributeMap = [
        'stats' => 'stats',
        'value' => 'value',
        'streak' => 'streak',
        'streak_progress_required' => 'streak_progress_required',
        'streak_reset_to_zero' => 'streak_reset_to_zero',
        'per_site_progress_maximum' => 'per_site_progress_maximum',
        'category_id' => 'category_id',
        'achievement_ids' => 'achievement_ids'
    ];


    /**
     * Array of attributes to setter functions (for deserialization of responses)
     * @var string[]
     */
    protected static $setters = [
        'stats' => 'setStats',
        'value' => 'setValue',
        'streak' => 'setStreak',
        'streak_progress_required' => 'setStreakProgressRequired',
        'streak_reset_to_zero' => 'setStreakResetToZero',
        'per_site_progress_maximum' => 'setPerSiteProgressMaximum',
        'category_id' => 'setCategoryId',
        'achievement_ids' => 'setAchievementIds'
    ];


    /**
     * Array of attributes to getter functions (for serialization of requests)
     * @var string[]
     */
    protected static $getters = [
        'stats' => 'getStats',
        'value' => 'getValue',
        'streak' => 'getStreak',
        'streak_progress_required' => 'getStreakProgressRequired',
        'streak_reset_to_zero' => 'getStreakResetToZero',
        'per_site_progress_maximum' => 'getPerSiteProgressMaximum',
        'category_id' => 'getCategoryId',
        'achievement_ids' => 'getAchievementIds'
    ];

    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    public static function setters()
    {
        return self::$setters;
    }

    public static function getters()
    {
        return self::$getters;
    }

    const STREAK_NONE = 'none';
    const STREAK_HOURLY = 'hourly';
    const STREAK_DAILY = 'daily';
    const STREAK_WEEKLY = 'weekly';
    const STREAK_MONTHLY = 'monthly';
    const STREAK_YEARLY = 'yearly';
    

    
    /**
     * Gets allowable values of the enum
     * @return string[]
     */
    public function getStreakAllowableValues()
    {
        return [
            self::STREAK_NONE,
            self::STREAK_HOURLY,
            self::STREAK_DAILY,
            self::STREAK_WEEKLY,
            self::STREAK_MONTHLY,
            self::STREAK_YEARLY,
        ];
    }
    

    /**
     * Associative array for storing property values
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     * @param mixed[] $data Associated array of property values initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['stats'] = isset($data['stats']) ? $data['stats'] : null;
        $this->container['value'] = isset($data['value']) ? $data['value'] : null;
        $this->container['streak'] = isset($data['streak']) ? $data['streak'] : null;
        $this->container['streak_progress_required'] = isset($data['streak_progress_required']) ? $data['streak_progress_required'] : null;
        $this->container['streak_reset_to_zero'] = isset($data['streak_reset_to_zero']) ? $data['streak_reset_to_zero'] : null;
        $this->container['per_site_progress_maximum'] = isset($data['per_site_progress_maximum']) ? $data['per_site_progress_maximum'] : null;
        $this->container['category_id'] = isset($data['category_id']) ? $data['category_id'] : null;
        $this->container['achievement_ids'] = isset($data['achievement_ids']) ? $data['achievement_ids'] : null;
    }

    /**
     * show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalid_properties = [];
        $allowed_values = ["none", "hourly", "daily", "weekly", "monthly", "yearly"];
        if (!in_array($this->container['streak'], $allowed_values)) {
            $invalid_properties[] = "invalid value for 'streak', must be one of #{allowed_values}.";
        }

        return $invalid_properties;
    }

    /**
     * validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properteis are valid
     */
    public function valid()
    {
        $allowed_values = ["none", "hourly", "daily", "weekly", "monthly", "yearly"];
        if (!in_array($this->container['streak'], $allowed_values)) {
            return false;
        }
        return true;
    }


    /**
     * Gets stats
     * @return \Swagger\Client\Model\Stat[]
     */
    public function getStats()
    {
        return $this->container['stats'];
    }

    /**
     * Sets stats
     * @param \Swagger\Client\Model\Stat[] $stats These stats count for progress towards the achievement.
     * @return $this
     */
    public function setStats($stats)
    {
        $this->container['stats'] = $stats;

        return $this;
    }

    /**
     * Gets value
     * @return int
     */
    public function getValue()
    {
        return $this->container['value'];
    }

    /**
     * Sets value
     * @param int $value The total value required of the stats for this achievement for the achievement to be awarded.
     * @return $this
     */
    public function setValue($value)
    {
        $this->container['value'] = $value;

        return $this;
    }

    /**
     * Gets streak
     * @return string
     */
    public function getStreak()
    {
        return $this->container['streak'];
    }

    /**
     * Sets streak
     * @param string $streak If not \"none\", progress towards this achievement can only be made once every streak period, and progress will be reset if progress is not made for an entire streak period.
     * @return $this
     */
    public function setStreak($streak)
    {
        $allowed_values = array('none', 'hourly', 'daily', 'weekly', 'monthly', 'yearly');
        if (!is_null($streak) && (!in_array($streak, $allowed_values))) {
            throw new \InvalidArgumentException("Invalid value for 'streak', must be one of 'none', 'hourly', 'daily', 'weekly', 'monthly', 'yearly'");
        }
        $this->container['streak'] = $streak;

        return $this;
    }

    /**
     * Gets streak_progress_required
     * @return int
     */
    public function getStreakProgressRequired()
    {
        return $this->container['streak_progress_required'];
    }

    /**
     * Sets streak_progress_required
     * @param int $streak_progress_required If streak is not \"none\", progress towards this achievement during each streak period may be made up to this value.  If progress is only partially made to this value, it will be reset in the next streak period.  For example, to implement an achievement described \"Edit a wiki 5 times a day for 5 days\", this would be 5 and value would be 25.
     * @return $this
     */
    public function setStreakProgressRequired($streak_progress_required)
    {
        $this->container['streak_progress_required'] = $streak_progress_required;

        return $this;
    }

    /**
     * Gets streak_reset_to_zero
     * @return bool
     */
    public function getStreakResetToZero()
    {
        return $this->container['streak_reset_to_zero'];
    }

    /**
     * Sets streak_reset_to_zero
     * @param bool $streak_reset_to_zero If true, progress towards the streak will be reset to zero when the streak period expires without any progress.  If false, progress will only be reset when partial progress is made as described under streak_progress_required.
     * @return $this
     */
    public function setStreakResetToZero($streak_reset_to_zero)
    {
        $this->container['streak_reset_to_zero'] = $streak_reset_to_zero;

        return $this;
    }

    /**
     * Gets per_site_progress_maximum
     * @return int
     */
    public function getPerSiteProgressMaximum()
    {
        return $this->container['per_site_progress_maximum'];
    }

    /**
     * Sets per_site_progress_maximum
     * @param int $per_site_progress_maximum If not 0, progress towards this achievement can only be made up to this value on each individual site.  For an achievement described \"Contributed to 50 different wikis\", this would be 1 and `value` would be 50.  Note that this only makes sense for achievements which are marked global.
     * @return $this
     */
    public function setPerSiteProgressMaximum($per_site_progress_maximum)
    {
        $this->container['per_site_progress_maximum'] = $per_site_progress_maximum;

        return $this;
    }

    /**
     * Gets category_id
     * @return int
     */
    public function getCategoryId()
    {
        return $this->container['category_id'];
    }

    /**
     * Sets category_id
     * @param int $category_id If not 0, this achievement is awarded when all other achievements in the category are complete.
     * @return $this
     */
    public function setCategoryId($category_id)
    {
        $this->container['category_id'] = $category_id;

        return $this;
    }

    /**
     * Gets achievement_ids
     * @return int[]
     */
    public function getAchievementIds()
    {
        return $this->container['achievement_ids'];
    }

    /**
     * Sets achievement_ids
     * @param int[] $achievement_ids If not empty, this achievement is awared when all of the achievements specified by the ids in this list are complete.
     * @return $this
     */
    public function setAchievementIds($achievement_ids)
    {
        $this->container['achievement_ids'] = $achievement_ids;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     * @param  integer $offset Offset
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     * @param  integer $offset Offset
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     * @param  integer $offset Offset
     * @param  mixed   $value  Value to be set
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     * @param  integer $offset Offset
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(\Swagger\Client\ObjectSerializer::sanitizeForSerialization($this), JSON_PRETTY_PRINT);
        }

        return json_encode(\Swagger\Client\ObjectSerializer::sanitizeForSerialization($this));
    }
}


